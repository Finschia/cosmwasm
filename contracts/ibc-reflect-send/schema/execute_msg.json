{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ExecuteMsg",
  "anyOf": [
    {
      "description": "Changes the admin",
      "type": "object",
      "required": [
        "update_admin"
      ],
      "properties": {
        "update_admin": {
          "type": "object",
          "required": [
            "admin"
          ],
          "properties": {
            "admin": {
              "$ref": "#/definitions/HumanAddr"
            }
          }
        }
      }
    },
    {
      "type": "object",
      "required": [
        "send_msgs"
      ],
      "properties": {
        "send_msgs": {
          "type": "object",
          "required": [
            "channel_id",
            "msgs"
          ],
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "msgs": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/CosmosMsg_for_Empty"
              }
            }
          }
        }
      }
    },
    {
      "type": "object",
      "required": [
        "check_remote_balance"
      ],
      "properties": {
        "check_remote_balance": {
          "type": "object",
          "required": [
            "channel_id"
          ],
          "properties": {
            "channel_id": {
              "type": "string"
            }
          }
        }
      }
    },
    {
      "description": "If you sent funds to this contract, it will attempt to ibc transfer them to the account on the remote side of this channel. If we don't have the address yet, this fails.",
      "type": "object",
      "required": [
        "send_funds"
      ],
      "properties": {
        "send_funds": {
          "type": "object",
          "required": [
            "reflect_channel_id",
            "transfer_channel_id"
          ],
          "properties": {
            "reflect_channel_id": {
              "description": "The channel id we use above to talk with the reflect contract",
              "type": "string"
            },
            "transfer_channel_id": {
              "description": "The channel to use for ibctransfer. This is bound to a different port and handled by a different module. It should connect to the same chain as the reflect_channel_id does",
              "type": "string"
            }
          }
        }
      }
    }
  ],
  "definitions": {
    "BankMsg": {
      "description": "The message types of the bank module.\n\nSee https://github.com/line/lfb-sdk/blob/develop/proto/lfb/bank/v1beta1/tx.proto.",
      "anyOf": [
        {
          "description": "Sends native tokens from the contract to the given address.\n\nThis is translated to a MsgSend in https://github.com/line/lfb-sdk/blob/develop/proto/lfb/bank/v1beta1/tx.proto. `from_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "send"
          ],
          "properties": {
            "send": {
              "type": "object",
              "required": [
                "amount",
                "to_address"
              ],
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                },
                "to_address": {
                  "$ref": "#/definitions/HumanAddr"
                }
              }
            }
          }
        }
      ]
    },
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
      "type": "string"
    },
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "CosmosMsg_for_Empty": {
      "anyOf": [
        {
          "type": "object",
          "required": [
            "bank"
          ],
          "properties": {
            "bank": {
              "$ref": "#/definitions/BankMsg"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "custom"
          ],
          "properties": {
            "custom": {
              "$ref": "#/definitions/Empty"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "staking"
          ],
          "properties": {
            "staking": {
              "$ref": "#/definitions/StakingMsg"
            }
          }
        },
        {
          "description": "A Stargate message encoded the same way as a protobof [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)",
          "type": "object",
          "required": [
            "stargate"
          ],
          "properties": {
            "stargate": {
              "type": "object",
              "required": [
                "type_url",
                "value"
              ],
              "properties": {
                "type_url": {
                  "type": "string"
                },
                "value": {
                  "$ref": "#/definitions/Binary"
                }
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "ibc"
          ],
          "properties": {
            "ibc": {
              "$ref": "#/definitions/IbcMsg"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "wasm"
          ],
          "properties": {
            "wasm": {
              "$ref": "#/definitions/WasmMsg"
            }
          }
        }
      ]
    },
    "Empty": {
      "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
      "type": "object"
    },
    "HumanAddr": {
      "type": "string"
    },
    "IbcMsg": {
      "description": "These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)",
      "anyOf": [
        {
          "description": "Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.",
          "type": "object",
          "required": [
            "transfer"
          ],
          "properties": {
            "transfer": {
              "type": "object",
              "required": [
                "amount",
                "channel_id",
                "to_address"
              ],
              "properties": {
                "amount": {
                  "description": "packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Coin"
                    }
                  ]
                },
                "channel_id": {
                  "description": "exisiting channel to send the tokens over",
                  "type": "string"
                },
                "timeout_block": {
                  "description": "block after which the packet times out. at least one of timeout_block, timeout_timestamp is required",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/IbcTimeoutBlock"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "timeout_timestamp": {
                  "description": "block timestamp (nanoseconds since UNIX epoch) after which the packet times out. See https://golang.org/pkg/time/#Time.UnixNano at least one of timeout_block, timeout_timestamp is required",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                },
                "to_address": {
                  "description": "address on the remote chain to receive these tokens",
                  "allOf": [
                    {
                      "$ref": "#/definitions/HumanAddr"
                    }
                  ]
                }
              }
            }
          }
        },
        {
          "description": "Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.",
          "type": "object",
          "required": [
            "send_packet"
          ],
          "properties": {
            "send_packet": {
              "type": "object",
              "required": [
                "channel_id",
                "data"
              ],
              "properties": {
                "channel_id": {
                  "type": "string"
                },
                "data": {
                  "$ref": "#/definitions/Binary"
                },
                "timeout_block": {
                  "description": "block height after which the packet times out. at least one of timeout_block, timeout_timestamp is required",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/IbcTimeoutBlock"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "timeout_timestamp": {
                  "description": "block timestamp (nanoseconds since UNIX epoch) after which the packet times out. See https://golang.org/pkg/time/#Time.UnixNano at least one of timeout_block, timeout_timestamp is required",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          }
        },
        {
          "description": "This will close an existing channel that is owned by this contract. Port is auto-assigned to the contracts' ibc port",
          "type": "object",
          "required": [
            "close_channel"
          ],
          "properties": {
            "close_channel": {
              "type": "object",
              "required": [
                "channel_id"
              ],
              "properties": {
                "channel_id": {
                  "type": "string"
                }
              }
            }
          }
        }
      ]
    },
    "IbcTimeoutBlock": {
      "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
      "type": "object",
      "required": [
        "height",
        "revision"
      ],
      "properties": {
        "height": {
          "description": "block height after which the packet times out. the height within the given revision",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "revision": {
          "description": "the version that the client is currently on (eg. after reseting the chain this could increment 1 as height drops to 0)",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "StakingMsg": {
      "description": "The message types of the staking module.\n\nSee https://github.com/line/lfb-sdk/blob/develop/proto/lfb/staking/v1beta1/tx.proto.",
      "anyOf": [
        {
          "description": "This is translated to a MsgDelegate in https://github.com/line/lfb-sdk/blob/develop/proto/lfb/staking/v1beta1/tx.proto. `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "delegate"
          ],
          "properties": {
            "delegate": {
              "type": "object",
              "required": [
                "amount",
                "validator"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Coin"
                },
                "validator": {
                  "$ref": "#/definitions/HumanAddr"
                }
              }
            }
          }
        },
        {
          "description": "This is translated to a MsgUndelegate in https://github.com/line/lfb-sdk/blob/develop/proto/lfb/staking/v1beta1/tx.proto. `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "undelegate"
          ],
          "properties": {
            "undelegate": {
              "type": "object",
              "required": [
                "amount",
                "validator"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Coin"
                },
                "validator": {
                  "$ref": "#/definitions/HumanAddr"
                }
              }
            }
          }
        },
        {
          "description": "This is translated to a MsgSetWithdrawAddress in https://github.com/line/lfb-sdk/blob/develop/proto/lfb/distribution/v1beta1/tx.proto. followed by a MsgWithdrawDelegatorReward in https://github.com/line/lfb-sdk/blob/develop/proto/lfb/distribution/v1beta1/tx.proto. `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "withdraw"
          ],
          "properties": {
            "withdraw": {
              "type": "object",
              "required": [
                "validator"
              ],
              "properties": {
                "recipient": {
                  "description": "this is the \"withdraw address\", the one that should receive the rewards if None, then use delegator address",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/HumanAddr"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "validator": {
                  "$ref": "#/definitions/HumanAddr"
                }
              }
            }
          }
        },
        {
          "description": "This is translated to a MsgBeginRedelegate in https://github.com/line/lfb-sdk/blob/develop/proto/lfb/staking/v1beta1/tx.proto. `delegator_address` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "redelegate"
          ],
          "properties": {
            "redelegate": {
              "type": "object",
              "required": [
                "amount",
                "dst_validator",
                "src_validator"
              ],
              "properties": {
                "amount": {
                  "$ref": "#/definitions/Coin"
                },
                "dst_validator": {
                  "$ref": "#/definitions/HumanAddr"
                },
                "src_validator": {
                  "$ref": "#/definitions/HumanAddr"
                }
              }
            }
          }
        }
      ]
    },
    "Uint128": {
      "type": "string"
    },
    "WasmMsg": {
      "description": "The message types of the wasm module.\n\nSee https://github.com/line/lfb-sdk/blob/develop/x/wasm/internal/types/tx.proto.",
      "anyOf": [
        {
          "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a MsgExecuteContract in https://github.com/line/lfb-sdk/blob/develop/x/wasm/internal/types/tx.proto. `sender` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "execute"
          ],
          "properties": {
            "execute": {
              "type": "object",
              "required": [
                "contract_addr",
                "msg",
                "send"
              ],
              "properties": {
                "contract_addr": {
                  "$ref": "#/definitions/HumanAddr"
                },
                "msg": {
                  "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Binary"
                    }
                  ]
                },
                "send": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              }
            }
          }
        },
        {
          "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThis is translated to a MsgInstantiateContract in https://github.com/line/lfb-sdk/blob/develop/x/wasm/internal/types/tx.proto. `sender` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "instantiate"
          ],
          "properties": {
            "instantiate": {
              "type": "object",
              "required": [
                "code_id",
                "label",
                "msg",
                "send"
              ],
              "properties": {
                "code_id": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                },
                "label": {
                  "description": "A human-readbale label for the contract",
                  "type": "string"
                },
                "msg": {
                  "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Binary"
                    }
                  ]
                },
                "send": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              }
            }
          }
        },
        {
          "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a MsgMigrateContract in https://github.com/line/lfb-sdk/blob/develop/x/wasm/internal/types/tx.proto. `sender` is automatically filled with the current contract's address.",
          "type": "object",
          "required": [
            "migrate"
          ],
          "properties": {
            "migrate": {
              "type": "object",
              "required": [
                "contract_addr",
                "msg",
                "new_code_id"
              ],
              "properties": {
                "contract_addr": {
                  "$ref": "#/definitions/HumanAddr"
                },
                "msg": {
                  "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Binary"
                    }
                  ]
                },
                "new_code_id": {
                  "description": "the code_id of the new logic to place in the given contract",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              }
            }
          }
        }
      ]
    }
  }
}
